import assert from "assert"
import Node, { NODE_BALANCING, NodeCloningOptions } from "../node"
import { LIST } from "../type/declarations/separator"
import { isNil, isString, last, sortedIndex, sortedIndexBy } from "lodash"

import { Interval, Point, Range } from "@december/utils"
import { Grid } from "@december/logger"
import churchill, { Block, paint, Paint } from "../logger"
import { PartialDeep } from "type-fest"

import TreePrinter, { PrintOptions } from "./printer"
import { BY_TYPE } from "../type/styles"
import { NIL } from "../type/declarations/literal"
import { inOrder, postOrder } from "../node/traversal"

export const _logger = churchill.child(`node`, undefined, { separator: `` })

export interface TreeCloningOptions extends NodeCloningOptions {}

export default class Tree {
  public expression: string
  public root: Node

  constructor(expression: string, root?: Node) {
    this.expression = expression
    // const totality = Range.fromLength(0, expression.length).addEntry(new Point(0)).addEntry(new Point(expression.length))
    const totality = Range.fromLength(0, expression.length)
    this.root = root ?? Node.ROOT(totality)
    this.root.tree = this
  }

  get height() {
    return this.root.height
  }

  /** Returns a list of nodes (in-order) per level of the tree */
  nodesByLevel(): Node[][] {
    const nodes: Node[][] = []

    const queue: Node[] = [this.root]

    while (queue.length) {
      const levelNodes: Node[] = []

      let size = queue.length
      while (size) {
        const node = queue.shift()!
        levelNodes.push(node)

        // gather all the children of node dequeued and enqueue them(left/right nodes)
        node.children.forEach(child => queue.push(child))

        size--
      }

      nodes.push(levelNodes)
    }

    return nodes
  }

  /** Returns a list of nodes (in-order) at a level of the tree */
  _nodesByLevel(level: number, node?: Node): Node[] {
    if (node === undefined) node = this.root

    if (node.level === level) return [node]
    else return node.children.flatMap(child => this._nodesByLevel(level, child))
  }

  print(from: Node, options: PrintOptions = {}) {
    TreePrinter.print(this, from, options)
  }

  clone(options: Partial<TreeCloningOptions> = {}) {
    const tree = new Tree(this.expression, this.root.clone(options))

    const queue = [this.root]

    // replicate
    while (queue.length) {
      const ATParent = queue.shift()!

      const parent = tree.root.find(node => node.id === ATParent.id)!

      assert(parent, `Parent node not found`)

      // insert node at ST
      for (const ATNode of ATParent.children) {
        const node = ATNode.clone(options)

        node.setAttributes({
          ...(node.attributes ?? {}),
          originalNodes: [ATNode],
        })

        parent._addChild(node)

        queue.push(ATNode) // enqueue child
      }
    }

    return tree
  }

  /** Traverse tree by level */
  traverse(predicate: (node: Node) => void) {
    predicate(this.root)

    const queue: Node[] = [this.root]

    while (queue.length) {
      const parent = queue.shift()!

      for (const node of parent.children) {
        predicate(node)

        queue.push(node)
      }
    }
  }

  recalculate() {
    // TODO: Improve this method to recalculate ranges

    let expression = ``

    // recalculate ranges and final expression
    let cursor = 0
    inOrder(this.root, (node, token, ignorable) => {
      if (ignorable) debugger

      // if (node._range) debugger

      if (!token) {
        debugger
      } else {
        const length = token.interval.length
        expression += token.lexeme

        assert(length === token.lexeme.length, `Length mismatch`)

        token.updateInterval(Interval.fromLength(cursor, length))
        cursor += length
      }
    })

    // update local expression for all tokens
    this.root._range = Range.fromLength(0, expression.length).addEntry(new Point(0)).addEntry(new Point(expression.length))
    this.expression = expression
    postOrder(this.root, node => node.tokens.map(token => token.updateExpression(expression)))

    return expression
  }
}
