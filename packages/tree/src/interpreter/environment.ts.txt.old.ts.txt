import assert from "assert"

import { Match } from "@december/utils"

import { ProxyVariableValue, RuntimeValue } from "./runtime"
import { MaybeUndefined, Nullable } from "tsdef"

export type VariableName = string

export interface ResolutionPattern {
  pattern: Match.Pattern
  variableName: VariableName
}

export interface ResolvedVariableName {
  variableName: VariableName
  environment: Environment
}

export const VARIABLE_NOT_FOUND: unique symbol = Symbol.for(`environment:variable-not-found`)
export type VariableNotFound = typeof VARIABLE_NOT_FOUND

export const UNDEFINED_VALUE: unique symbol = Symbol.for(`environment:undefined-value`)
export type UndefinedValue = typeof UNDEFINED_VALUE

export type EnvironmentGetter<TValue> = (variableName: VariableName, environment: Environment) => RuntimeValue<TValue>

export default class Environment {
  private _snapshot: number = 0
  //
  public name: string
  private parent?: Environment
  //
  private patterns: Map<string, ResolutionPattern> // patterns to resolve variable names
  public variables: Map<VariableName, RuntimeValue<any>>

  constructor(name: string, parent?: Environment) {
    this.name = name
    this.parent = parent
    //
    this.patterns = new Map()
    this.variables = new Map()
  }

  // /** Check all patterns to resolve variable name */
  // public resolveByPattern(unresolvedVariableName: VariableName): MaybeUndefined<ResolvedVariableName> {
  //   for (const [key, { pattern, variableName }] of this.patterns) {
  //     const match = pattern.match(unresolvedVariableName)
  //     if (match.isMatch) return { variableName, environment: this }
  //   }

  //   return undefined
  // }

  /** Check all patterns to resolve variable name */
  public getVariableNameByPattern(unresolvedVariableName: VariableName): MaybeUndefined<ResolutionPattern> {
    for (const resolutionPattern of this.patterns.values()) {
      const { pattern, variableName } = resolutionPattern
      const match = pattern.match(unresolvedVariableName)
      if (match.isMatch) return resolutionPattern
    }

    return undefined
  }

  /** Resolve variable name through environment tree. A variable could point to another variable (by pattern or ProxyVariableValue) */
  public resolve(unresolvedVariableName: VariableName, entryEnvironment?: Environment): VariableNameResolution | VariableNotFound {
    entryEnvironment ??= this

    // 1. Check if this environment has the variable name
    if (this.variables.has(unresolvedVariableName)) {
      //     (only for NON-ProxyVariableValue)
      const value = this.variables.get(unresolvedVariableName)!
      if (!ProxyVariableValue.isProxyVariableValue(value))
        return {
          unresolvedVariableName,
          variableName: unresolvedVariableName,
          environment: this,
          trace: [{ type: `variable_present`, environment: this }],
        }

      // 2. Resolve ProxyVariableValue all over again (from the start)
      const resolvedVariableName = entryEnvironment.resolve(value.value, entryEnvironment)
      if (resolvedVariableName === VARIABLE_NOT_FOUND) return VARIABLE_NOT_FOUND // if we could not resolve ProxyVariableValue

      return {
        unresolvedVariableName,
        variableName: resolvedVariableName.variableName,
        environment: resolvedVariableName.environment,
        trace: [{ type: `proxy_by_runtime_value`, environment: this, proxyVariableValue: value }, ...resolvedVariableName.trace],
      }
    }

    // 3. Check if variable name follows a pattern
    const variableNameByPattern = this.getVariableNameByPattern(unresolvedVariableName)
    //      (when we get a NEW variable name from pattern, try to resolve from the start)
    if (variableNameByPattern) {
      const resolvedVariableName = entryEnvironment.resolve(variableNameByPattern.variableName, entryEnvironment)
      if (resolvedVariableName === VARIABLE_NOT_FOUND) return VARIABLE_NOT_FOUND // if we could not resolve patterned variable name

      return {
        unresolvedVariableName,
        variableName: variableNameByPattern.variableName,
        environment: resolvedVariableName.environment,
        trace: [{ type: `proxy_by_pattern`, environment: this, pattern: variableNameByPattern }, ...resolvedVariableName.trace],
      }
    }

    // 4. Ask parent
    if (this.parent) return this.parent.resolve(unresolvedVariableName, entryEnvironment)

    return VARIABLE_NOT_FOUND
  }

  /** Resolve variable name in environment tree. Only returns IF the variable name exists in SOME environment */
  public res1olve(unresolvedVariableName: VariableName, entryEnvironment?: Environment): ResolvedVariableName | VariableNotFound {
    entryEnvironment ??= this

    // 1. Just a plain old variable
    if (this.variables.has(unresolvedVariableName)) return { variableName: unresolvedVariableName, environment: this }

    // 2. Variable following a dynamic pattern
    const variableNameByPattern = this.getVariableNameByPattern(unresolvedVariableName)
    //      (when we get a NEW variable name from pattern, try to resolve from the start)
    if (variableNameByPattern) return entryEnvironment.resolve(variableNameByPattern, entryEnvironment)

    // 3. Try to resolve in parent environment
    if (this.parent) return this.parent.resolve(unresolvedVariableName, entryEnvironment)

    // throw new Error(`Variable "${unresolvedVariableName}" not found in this environment.`)
    return VARIABLE_NOT_FOUND
  }

  // /** Check if environment has variable name */
  // public has(unresolvedVariableName: VariableName): boolean {
  //   const resolvedVariable = this.resolve(unresolvedVariableName)
  //   if (resolvedVariable === VARIABLE_NOT_FOUND) return false

  //   const { variableName, environment } = resolvedVariable

  //   // 2. Get the value from the resolved variable name
  //   return environment.variables.has(variableName)
  // }

  /** Get variable name value from environment tree */
  public get(unresolvedVariableName: VariableName): RuntimeValue<any> | VariableNotFound {
    // 1. Resolve final variable name (if chained)
    const resolvedVariable = this.resolve(unresolvedVariableName)
    if (resolvedVariable === VARIABLE_NOT_FOUND) return VARIABLE_NOT_FOUND

    const { variableName, environment } = resolvedVariable

    // 2. Get the value from the resolved variable name
    if (environment.variables.has(variableName)) return environment.variables.get(variableName)!

    // throw new Error(`Variable "${unresolvedVariableName}" not found in this environment.`)
    return VARIABLE_NOT_FOUND
  }

  /** Assigns a runtime value to a variable name */
  public assignVariable<TRuntimeValue extends RuntimeValue<any> = RuntimeValue<any>>(variableName: VariableName, value: TRuntimeValue) {
    assert(!this.variables.has(variableName), `Variable "${variableName}" already defined in this environment.`)

    this.variables.set(variableName, value)
    this._snapshot++
  }

  /** Register a resolution pattern for "complex" variable names */
  public registerResolutionPattern(key: string, variableName: VariableName, pattern: Match.Pattern) {
    assert(!this.patterns.has(key), `Resolution pattern "${key}" already defined in this environment.`)

    this.patterns.set(key, { pattern, variableName })
    this._snapshot++
  }

  public getSnapshot(): string {
    return `${this.parent ? this.parent.getSnapshot() : ``}${this._snapshot}`
  }
}

export interface VariableNameResolution {
  unresolvedVariableName: VariableName
  variableName: VariableName
  environment: Nullable<Environment> // environment where variable value can be found
  trace: VariableNameResolutionTrace[]
}

export interface VariableNameResolutionTrace_VariablePresent {
  type: `variable_present`
  environment: Environment
}

export interface VariableNameResolutionTrace_ProxyByPattern {
  type: `proxy_by_pattern`
  environment: Environment
  pattern: ResolutionPattern
}

export interface VariableNameResolutionTrace_ProxyByRuntimeValue {
  type: `proxy_by_runtime_value`
  environment: Environment
  proxyVariableValue: ProxyVariableValue
}
export type VariableNameResolutionTrace = VariableNameResolutionTrace_VariablePresent | VariableNameResolutionTrace_ProxyByPattern | VariableNameResolutionTrace_ProxyByRuntimeValue
