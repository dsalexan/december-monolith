import assert from "assert"
import { AnyObject, Nilable, NonNil } from "tsdef"
import { get, isString } from "lodash"

import MutableObject from "../../object"

import { GenericMutationFrame, MutationFunctionOutput, MutationFunctionReturn } from "../frameRegistry/mutationFrame"
import { OVERRIDE } from "../../mutation"
import { Mutation } from "../../mutation/mutation"

import { preProcess, PreProcessOptions, reProcess, ReProcessOptions } from "../../processor"
import { ProcessingPackage, ProcessingPath, ReProcessingFunction } from "../../processor/base"

import type { ProxyListenerOptions } from "."
import { BareExecutionContext } from "../callQueue"
import { Environment } from "../../tree"
import { ReProcessedReturn } from "../../processor/reRrocess"
import { PreProcessedReturn } from "../../processor/preProcess"
import { Listener } from "../eventEmitter/listener"

// #region B. Process package into states and MutationFunctionReturn

export type StrategyPreProcessOptions = PreProcessOptions
export type StrategyReProcessOptions = ReProcessOptions & { fetchReference: (identifier: string, key: string) => Nilable<AnyObject> }
export type StrategyProcessingOutput<TProcessedValue extends PreProcessedReturn | ReProcessedReturn = PreProcessedReturn | ReProcessedReturn> = MutationFunctionOutput & { processedValue: TProcessedValue; listeners: Listener[] }
1
function isPreProcess(type: `pre-process` | `re-process`, value: ReturnType<typeof reProcess> | ReturnType<typeof preProcess>): value is ReturnType<typeof preProcess> {
  return type === `pre-process`
}

export function process(type: `pre-process`, processingPackage: ProcessingPackage, options: StrategyPreProcessOptions): StrategyProcessingOutput<PreProcessedReturn>
export function process(type: `re-process`, processingPackage: ProcessingPackage, options: StrategyReProcessOptions): StrategyProcessingOutput<ReProcessedReturn>
export function process(type: `pre-process` | `re-process`, processingPackage: ProcessingPackage, options: StrategyPreProcessOptions | StrategyReProcessOptions): StrategyProcessingOutput {
  const { object, path, reProcessingFunction, environment } = processingPackage

  // 1. Process expression
  let processedValue: ReturnType<typeof reProcess> | ReturnType<typeof preProcess>
  if (type === `pre-process`) {
    const expression = get(object.data, path.expression)
    assert(isString(expression), `Expression is not a string to be pre-processed`)

    processedValue = preProcess(processingPackage, { ...(options as StrategyPreProcessOptions) })
  } else {
    processedValue = reProcess(processingPackage, { ...(options as StrategyReProcessOptions) })
  }

  // 2. Override target path with new processed value
  if (processedValue.isReady) {
    const computedValue = processedValue.data.tree.value()

    // // DEBUG: This is just to simulate a "signature change" in re-process
    // // ====================================================
    // processedValue.signature.value = `aaaaa`
    // return [OVERRIDE(path.computed, computedValue), processedValue.signature.instruction()]
    // // ====================================================

    return { processedValue, mutations: [OVERRIDE(path.target, computedValue)], integrityEntries: [], listeners: [] }
  }

  // 3. Store processing state (if necessary)
  //      Processing state is saved in target while processing is not ready
  //      Pre-processing state storage ALSO creates/saves the integrity entries, so we are sure no new ones will be created in re-processing
  const state = isPreProcess(type, processedValue) ? processedValue.saveState(object, path.target) : get(object.metadata, path.target) // save state if we are pre-processing
  assert(state, `Processing state should exist here`)

  // 4. Store symbols relevant to processing
  const listeners = processedValue.listenForSymbols(processedValue.data.symbolTable, {
    name: reProcessingFunction.name,
    arguments: { ...reProcessingFunction.arguments, path },
  })

  // 5. Only pre-processing generate changes in the object while NOT READY
  return type === `pre-process` ? { processedValue, mutations: [...state.mutations], integrityEntries: [...state.integrityEntries], listeners } : { processedValue, mutations: [], integrityEntries: [], listeners }
}

// #endregion
