import { set, get, isNil, isString } from "lodash"
import assert from "assert"

import uuid from "@december/utils/uuid"

import { Environment, Processor, Simbol } from "@december/tree"
import SymbolTable from "@december/tree/environment/symbolTable"
import { ProcessorBuildOptions } from "@december/tree/processor"

import { UnitManager } from "@december/utils/unit"
import { PropertyReferencePattern } from "@december/utils/access"

import MutableObject from "../../object"
import { IntegrityEntry } from "../integrityRegistry"
import { Mutation } from "../../mutation/mutation"
import { ProcessingSymbolTranslationTable } from "./translationTable"
import { resolveTargetEvent } from "."
import { PROPERTY_UPDATED } from "../eventEmitter/event"
import { createListener, GenericListener, Listener } from "../eventEmitter/listener"
import { ReProcessingFunction } from "../../processor/base"
import { MaybeUndefined, Nullable } from "tsdef"

// #region PROCESSING

export type StrategyProcessOptions = {
  unitManager: UnitManager
} & ProcessorBuildOptions

export type ProcessingSymbolsIndex = Record<Simbol[`content`], { symbols: Simbol[]; listened: boolean }>

export interface ProcessingState {
  id: string
  processor: Processor
  integrityEntries: IntegrityEntry[]
  //
  symbols: ProcessingSymbolsIndex
}

// #endregion

// #region LISTENING

export type SymbolListenableChecker = (symbol: Simbol) => boolean
export type PropertyPatternsFromSymbolGetter = (symbol: Simbol, translationTable: ProcessingSymbolTranslationTable) => PropertyReferencePattern[]

export interface StrategyListenOptions {
  canListenToSymbol: SymbolListenableChecker
  getPropertyPatternsFromSymbol: PropertyPatternsFromSymbolGetter
}

// #endregion

export class StrategyProcessor {
  constructor() {}

  /** Process expression */
  public static process(expression: string, environment: Nullable<Environment>, options: StrategyProcessOptions): ProcessingState {
    // 1. Make processor instance dedicated to expression
    const processor = new Processor()
    const grammar = processor.makeGrammar(options.unitManager)
    processor.initialize(grammar)

    // 2. Build tree from expression (i.e. expression -> Semantic Tree)
    let output = processor.build(expression, options)

    // 3. Try to solve tree using whatever we have now
    if (environment && !processor.isReady(output)) output = processor.resolve(output, environment)

    // 4. Cache up-to-date data into state
    return {
      id: `processing-state::${uuid().substring(0, 8)}`,
      processor,
      integrityEntries: [],
      //
      symbols: {},
    }
  }

  /** Store processing state in object metadata */
  public static store(state: ProcessingState, object: MutableObject, path: string): { mutations: Mutation[]; integrityEntries: IntegrityEntry[] } {
    const { processor } = state
    const expression = processor.preProcessedExpression

    // 1. Make integrity entry (it is registered when shipping mutations)
    const integrityEntries = [object.makeIntegrityEntry(path, expression)]
    state.integrityEntries = [...integrityEntries]

    // 3. Store state in metadata
    const mutations: Mutation[] = object.storeMetadata(state, path, integrityEntries)

    return { mutations, integrityEntries }
  }

  /** Get processing state from object metadata */
  public static getState(object: MutableObject, path: string): MaybeUndefined<ProcessingState> {
    const state: ProcessingState = get(object.metadata, path)
    return state
  }

  // TODO: REGISTER NEW SYMBOLS TO STATE'S INDEX EARLIER
  /** Listen for symbols in centralized object controller */
  public static listenForSymbols(
    state: ProcessingState, //
    object: MutableObject,
    translationTable: ProcessingSymbolTranslationTable,
    reProcessingFunction: ReProcessingFunction | string = `compute:re-processing`,
    options: StrategyListenOptions,
  ): Listener[] {
    const { processor } = state
    const tree = processor.resolvedTree

    // 1. Get all "listenable" symbols
    const symbolTable = SymbolTable.from(tree, processor.options.scope)
    const tableSymbols = symbolTable.filter(symbol => {
      return translationTable.has(symbol) || options.canListenToSymbol(symbol)
    })

    // 2. Store and listen to new symbols
    const listeners: Listener[] = []
    for (const simbol of tableSymbols) {
      const key = simbol.value

      // 3. Store symbol
      if (!state.symbols[key]) state.symbols[key] = { symbols: [simbol], listened: false }
      else if (!state.symbols[key].symbols.find(symbol => symbol.node.id !== simbol.node.id)) state.symbols[key].symbols.push(simbol)

      if (!state.symbols[key].listened) {
        // 4. Parse re-processing function name and arguments
        const name = isString(reProcessingFunction) ? reProcessingFunction : reProcessingFunction.name
        const args = isString(reProcessingFunction) ? {} : reProcessingFunction.arguments

        // 5. Update state
        state.symbols[key].listened = true

        // 6. Create listeners for symbol
        const propertyPatterns = options.getPropertyPatternsFromSymbol(simbol, translationTable)

        const genericListener: GenericListener = {
          // handle self properties (should be any here, thou)
          targetEvent: resolveTargetEvent(object, PROPERTY_UPDATED(...propertyPatterns)),
          // enqueue re-processing function on event (i.e. when any of the properties tied to symbol is updated)
          callback: (event, { eventEmitter }) => {
            eventEmitter.controller.callQueue.enqueue(object.reference(), {
              eventDispatcher: event,
              name,
              arguments: { ...args, state },
            })
          },
          // if any integrity entry changes, kill this listener
          integrityEntries: state.integrityEntries,
        }

        // 7. Return full listener
        listeners.push(createListener(object.id, genericListener))
      }
    }

    return listeners
  }
}
